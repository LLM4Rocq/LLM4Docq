Here is a some context to understand the following Coq source file from the mathcomp library:

This file provides the core definitions, notations, structures, and foundational theorems for handling matrices and their basic linear algebra operations in the Mathematical Components (MathComp) library for the Coq proof assistant. The code establishes a uniform and extensible formalization of matrices over arbitrary types, including (semi)rings and fields, and is designed to serve as the mathematical backbone for further developments in linear algebra (such as determinants, inverses, block matrices, and canonical forms).

Mathematical Objects


    Matrices: The central object is the type of m-by-n matrices over a ring (or other suitable structure) R (denoted as 'M[R]_(m, n)), formally represented as finite functions from pairs of indices to R.

    Special Matrices: The file introduces special cases:
        Square matrices 'M[R]_n (n×n), row vectors 'rV[R]_n (1×n), column vectors 'cV[R]_n (n×1).
        Permutation, scalar, diagonal, and identity matrices (e.g., perm_mx, scalar_mx, diag_mx, 1%:M).
        Block matrices: Complex and flexible ways to assemble or partition matrices into blocks of variable or fixed sizes.

    Linear Algebra Operations:
        Matrix addition and multiplication (+, *m)
        Transposition (^T)
        Determinant (\det)
        Trace (\tr)
        Adjugate and cofactor matrices (\adj, cofactor)
        Inverse matrices and characterizations of invertibility


Key Concepts and Notation Conventions


    Type Parameters: Matrices are always parametrized by their coefficient type (R, which could be an arbitrary type, an eqType, a ringType, etc.), and their size in both dimensions (m, n).

    Abstraction: While the physical representation of a matrix is a finite function, all interaction is intended to be through the abstract operations exposed in this interface; users should work with matrices as abstract objects.

    Canonical Structures and Hierarchy: The file integrates with MathComp’s algebraic hierarchy via typeclasses and canonical structures. Matrices inherit algebraic structures (equality, operations, etc.) from their coefficients.

    Indices: Matrix indices are bounded natural numbers ('I_m, 'I_n) ensuring dimensions are properly managed by the type system, reducing the need for explicit boundary checks.

    Notational Conventions:
        Matrix Types: 'M_(m, n) (matrix), 'rV_n (row vector), 'cV_n (column vector)
        Matrix Construction and Access:
            \matrix_(i, j) E for constructing by entries.
            A i j for accessing the (i, j)-th element (coercion to function).
            row i A, col j A for extracting individual rows or columns.
        Blocks and Partitioning:
            row_mx, col_mx, block_mx, and block notations like \mxblock_, \mxdiag_ for complex block structures.
            Functions for extracting submatrices (e.g., lsubmx, ulsubmx, etc).
        Operators:
            A *m B: matrix multiplication.
            A ^T: transpose.
            A + B: addition.
            a *: A: scaling by a scalar.
            a%:M: scalar matrix (scalar on the diagonal).
            \tr A, \det A, \adj A: standard linear algebra operations.
        Setoid Operations and Structures: Matrix types are equipped (via Hierarchy Builder and canonical structures) with eqType, zmodType, ringType, and groupType instances as appropriate.

    Dimension Inference: Type-level dimensions and coercions (including castmx) are used to ensure shapes match, and to allow flexible but type-safe composition of matrices.


Implementation Highlights


    Representation Hiding: A matrix is internally defined as a wrapper (Variant matrix) over finite functions {{ffun 'I_m * 'I_n → R}}; users interact with abstract operations only.

    Block Matrices: Powerful operations and notations for assembling and disassembling complex matrices; useful in proofs and algorithms that require recursive or block-based reasoning.

    Main Lemmas and Results: The file formalizes not just the data structures but also proves foundational results such as:
        Properties of addition, multiplication, transposition (associativity, distributivity, etc.).
        Symmetry and relationships between block and non-block forms.
        Results on determinant linearity, trace, commutativity for special cases, and Laplace expansion.
        Cramer’s rule and its formal proof.

    Parametricity: The framework supports operations mapping matrices via morphisms over coefficient types (allowing transport of algebraic properties across field/ ring extensions).

    Finite and Countable Structures: When the coefficient type is finite, so is the matrix type, and instances are provided for finite and countable typeclasses.


Here is a Coq source file from the mathcomp library:

"{source}"

I need you to help me write all the docstring.

To do it, write a json corresponding to a list of all docstring, in the format:

[{{"fullname": "Definition trunc x := if 0 <= x then sval (trunc_subproof x) else 0%N.", "docstring": "The function trunc returns the greatest natural number less than or equal to x when x is at least zero by using the constructive truncation proof; otherwise it returns zero."}}, ....

More precisely, I want you do it for the following:

{missing}

Here are the guidelines to write the docstrings:

Follow these rules when writing “docstring”:

1.  **Natural language only.**  Do not use any mathematical symbols (like <, ≤, =, etc.).  
2.  **Complete sentences.**  Write at least one full sentence; use clear subject-verb-object structure.  
3.  **Explicit**.  Spell out operations and relationships in plain English (e.g. “less than” instead of “<”).  
4.  **Self-contained.**  Anyone reading just the docstring should understand what the lemma does without needing to see Coq syntax or names.  
5.  **Embedding-friendly.**  Avoid pronouns or references that need extra context (e.g. “this” or “it”); mention the inputs and outputs by name or role.  
6.  **Don't cite the name of the premise in the docstring**.

Here is some examples of good docstrings:

"A lemma stating that in a finite field F, the number of invertible elements equals the total number of elements in F minus one, since exactly the zero element is not invertible."
"A notation introducing {{unit R}} to denote the group of invertible elements of a ring R, enabling implicit conversion between units and ring elements as a subtype."
"A lemma stating that multiplication operation on the ring of integers modulo p is commutative."
"A notation denoting the type of integers modulo the maximum of p and two."
"A factory record asserting that a subset of a unital algebra contains zero and one, is closed under subtraction, multiplication, taking inverses of units, and scalar multiplication, thus forming a division-closed subalgebra."

Your final json must be contains in a json code block.