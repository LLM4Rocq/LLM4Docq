Here is a some context to understand the following Coq source file from the mathcomp library:


Finite Group Theory: Fundamentals and Core Structures

Overview
========
This file serves as a central aggregating module for the formalization of finite group theory in Coq, relying on and extending the Mathematical Components (MathComp) library. The primary goal is to provide a unified interface that collects the foundational and advanced components necessary for reasoning about the structure and properties of finite groups. By gathering together a wide range of exported modules, the file establishes the essential mathematical infrastructure for the theory of permutation groups, $p$-groups, group actions, and major classification results, preparing the ground for both further formalization and cross-module reuse in formal mathematics.

Mathematical Objects and their Representations
==============================================
This file manipulates, either directly or by importing dependencies, the following core mathematical structures, each represented as finite sets or types equipped with algebraic operations and properties:

1. **Finite Groups**: 
    - Finite groups are implemented as finite types equipped with a group law, inversion, and identity. Types, operations, and proofs about cosets, subgroups, quotient groups, and homomorphisms are enabled by the MathComp `finGroupType` abstraction.

2. **Abelian Groups**: 
    - Groups satisfying the commutative law; special results and simplifications apply to these when imported from the `abelian` module.

3. **Cyclic and Extraspecial Groups**: 
    - Cyclic groups (generated by a single element) and extraspecial groups (certain non-abelian $p$-groups with special central and commutator properties) are formalized as subtypes with constraining predicates on the finite group type.

4. **Commutator and Center**: 
    - The commutator subgroup, describing how non-commutative a group is, and the group center (the set of elements commuting with all others) are given as explicit subgroups with corresponding operations and theorems.

5. **Group Actions and Permutation Groups**: 
    - The action of a group on sets (transitive, primitive actions) is formalized using suitable type classes and coercions. Permutation groups (subgroups of the symmetric group acting on a finite set) and their orbits and stabilizers are equipped with rich reasoning infrastructure.

6. **Series, Compositions, and Decompositions**:
    - Group series (ascending/descending chains of subgroups such as derived, lower, and upper central series), composition series, and maximal/minimal subgroups are formal objects used to structure arguments and state classification results.

7. **Nilpotent and $p$-Groups**: 
    - The concepts of nilpotency (groups with transfinite lower central series) and $p$-groups (groups of order a power of a prime $p$) are implemented with concrete criteria and attached decision procedures.

8. **Sylow and Hall Subgroups**: 
    - Sylow’s theorems are represented with predicates and constructions for existence and conjugacy of $p$-subgroups, and similarly for Hall subgroups (subgroups whose order and index are relatively prime).

9. **Frobenius and Related Structures**: 
    - Frobenius groups (groups with a fixed-point-free action on a set) and closely related objects are available with characterizations and structure theorems.

10. **Group Functors and Morphisms**: 
    - Functions or relations that associate subgroups or algebraic structure to groups (gfuncctors) are provided for systematic reasoning about families of subgroups or morphisms.

11. **Modules over Finite Groups**: 
    - Extensions to modules provide bridge to representation theory via the `finmodule` formalization (vector spaces equipped with a group action).

12. **Alternating Groups & Burnside Applications**: 
    - Special finite simple groups such as alternating groups are provided, alongside modules that supply key apparatus for Burnside-type arguments and counting formulas.

Key Coding and Notational Conventions
=====================================
- **Canonical Structures and Type Classes**: 
    - The file makes heavy use of canonical structures, which guide the inference of typeclass-like properties (e.g., knowing when a subgroup is itself a finite group, or when an action is compatible with group operations).
- **Infix Operators and Scoped Notation**: 
    - Most algebraic operations ($*$, $^{{-1}}$, etc.) use infix or postfix notations. Each structure is typically associated with a scoped notation (e.g., `%g` for group elements, `%G` for group types) to disambiguate overloaded symbols.
- **Boolean Reflection of Predicates**: 
    - Central to MathComp is the replacement of propositional connectives with Boolean predicates wherever possible, allowing the use of symbolic rewriting tactics and reflection.
- **Proof Irrelevance and Small-Finite Types**: 
    - The development is restricted to finite types (often with decidable equality), and most constructions and theorems rely on the ability to compute over finite sets.
- **Exported Modules Pattern**: 
    - The file strictly uses `Export` (rather than just `Import`) to ensure any downstream user automatically inherits all notation, definitions, and lemmas from the modules listed here, enabling theory extension without further imports.

Intended Use and Context for Interpretation
==========================================
This file is intended to be included, either directly or indirectly, by any development aiming to formalize or reason about finite group theory within Coq, especially when relying on MathComp conventions and ecosystem. When reading a definition, lemma, or proof from code importing this file, the reader should assume all basic and advanced infrastructure for handling subgroups, group actions, classical series (composition, chief, lower/upper central), $p$-groups, simple groups, and permutation groups, along with all major theorems (e.g., Sylow, Jordan-Hölder, maximality principles), are available and in scope.

All definitions and theorems are to be interpreted using the finite-type setting, with an emphasis on effective computation and Boolean-based predicate reasoning. The conventions, terminology, and notation follow the core MathComp style, which is succinct, type-inference friendly, and emphasizes symbolic manipulation.

This top-level module thus abstracts away the complexity of individual imports, letting mathematicians and formal method practitioners access the core toolbox for finite group theory in a seamless, ready-to-use manner.



Here is a Coq source file from the mathcomp library:

"{source}"

I need you to help me write all the docstring.

To do it, write a json corresponding to a list of all docstring, in the format:

[{{"fullname": "Definition trunc x := if 0 <= x then sval (trunc_subproof x) else 0%N.", "docstring": "The function trunc returns the greatest natural number less than or equal to x when x is at least zero by using the constructive truncation proof; otherwise it returns zero."}}, ....

More precisely, I want you do it for the following:

{missing}

Here are the guidelines to write the docstrings:

Follow these rules when writing “docstring”:

1.  **Natural language only.**  Do not use any mathematical symbols (like <, ≤, =, etc.).  
2.  **Complete sentences.**  Write at least one full sentence; use clear subject-verb-object structure.  
3.  **Explicit**.  Spell out operations and relationships in plain English (e.g. “less than” instead of “<”).  
4.  **Self-contained.**  Anyone reading just the docstring should understand what the lemma does without needing to see Coq syntax or names.  
5.  **Embedding-friendly.**  Avoid pronouns or references that need extra context (e.g. “this” or “it”); mention the inputs and outputs by name or role.  
6.  **Don't cite the name of the premise in the docstring**.

Here is some examples of good docstrings:

"A lemma stating that in a finite field F, the number of invertible elements equals the total number of elements in F minus one, since exactly the zero element is not invertible."
"A notation introducing {{unit R}} to denote the group of invertible elements of a ring R, enabling implicit conversion between units and ring elements as a subtype."
"A lemma stating that multiplication operation on the ring of integers modulo p is commutative."
"A notation denoting the type of integers modulo the maximum of p and two."
"A factory record asserting that a subset of a unital algebra contains zero and one, is closed under subtraction, multiplication, taking inverses of units, and scalar multiplication, thus forming a division-closed subalgebra."

Your final json must be contains in a json code block.
